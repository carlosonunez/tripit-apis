#!/usr/bin/env bash
source $(dirname "$0")/helpers/shared_secrets.sh
source $(dirname "$0")/helpers/logging.sh
ENVIRONMENT="${ENVIRONMENT:-test}"
DEPLOY_FUNCTIONS_ONLY="${DEPLOY_FUNCTIONS_ONLY:-false}"
IS_LOCAL="${IS_LOCAL:-false}"
DOCKER_COMPOSE='docker-compose --log-level ERROR'
DOCKER_COMPOSE_AWS="$DOCKER_COMPOSE -f docker-compose.aws.yml"
DOCKER_COMPOSE_DEPLOY="$DOCKER_COMPOSE -f docker-compose.deploy.yml"
set -e

usage() {
  cat <<-USAGE
$(basename $0)
Deploys our functions onto serverless infrastructure.

ARGUMENTS

  -h, --help                    Prints this help screen.

ENVIRONMENT VARIABLES

  IS_LOCAL=false                Runs everything locally if true.

  ENVIRONMENT=test              The environment being deployed into.

  DEPLOY_FUNCTIONS_ONLY=false   Disable re-deploying infrastructure and skip
                                straight to deploying functions.

USAGE
}

is_local() {
  test "${IS_LOCAL,,}" == true
}

confirm_environment_or_fail() {
  grep -Eq "^(test|production)$" <<< "$ENVIRONMENT" && return 0

  usage
  >&2 echo "Not a valid environment: $ENVIRONMENT"
  exit 1
}

write_lambda_secrets_for_integration_testing() {
  if test "$ENVIRONMENT" != "test"
  then
    return
  fi
  info "Getting integration test API Gateway endpoint."
  endpoint_url=$($DOCKER_COMPOSE_DEPLOY run --service-ports \
      --rm serverless info --stage develop | \
    grep -E 'http.*\/ping' | \
    sed 's/.*\(http.*\)\/ping/\1/' | \
    tr -d $'\r' | \
    tr -d $'\n')

  info "Getting API Gateway default API key."
  api_key=$($DOCKER_COMPOSE_DEPLOY \
      run --service-ports --rm serverless info --stage develop | \
    grep -E 'default-tripit-key-dev:' | \
    sed 's/.*default-tripit-key-dev: //' | \
    tr -d $'\r' | \
    tr -d $'\n'
  )
  if test -z "$endpoint_url"
  then
    error "We couldn't find a deployed endpoint."
    exit 1
  fi
  if test -z "$api_key"
  then
    error "We couldn't find an API key."
    exit 1
  fi
  write_secret "$endpoint_url" "endpoint_name"
  write_secret "$api_key" "api_key"
}

write_infrastructure_secrets() {
  info "Getting infrastructure secrets."
  tf_output=$(2>&1 $DOCKER_COMPOSE_DEPLOY run --service-ports \
    -e ENVIRONMENT="$ENVIRONMENT" \
    --rm \
    terraform output | tr -d $'\r')
  info "Output: $tf_output"
  for output_var in app_account_ak app_account_sk certificate_arn
  do
    secret_value=$(grep -E "^$output_var = " <<< "$tf_output" | \
      sed "s/^$output_var = //")
    if test -z "$secret_value"
    then
      error "Unable to resolve secret: $output_var"
      exit 1
    fi
    info "===> ${output_var}: $secret_value"
    write_secret "$secret_value" "$output_var"
  done
}

deploy_serverless_infrastructure() {
  info "Deploying serverless infrastructure."
  $DOCKER_COMPOSE_DEPLOY run --build --service-ports --rm deploy-serverless-infra-"$ENVIRONMENT" &&
  if test "$ENVIRONMENT" == "production" && ! is_local
  then
    $DOCKER_COMPOSE_DEPLOY run --build --service-ports --rm deploy-serverless-domain-production &&
    write_infrastructure_secrets &&
    $DOCKER_COMPOSE_DEPLOY run --build --service-ports --rm deploy-serverless-domain-production
  fi
}

deploy_serverless_functions() {
  info "Deploying serverless functions."
  $DOCKER_COMPOSE_DEPLOY run --build --service-ports --rm deploy-serverless-functions-"$ENVIRONMENT" &&
    write_lambda_secrets_for_integration_testing
}

stop_localstack_if_local() {
  is_local || return 0
  info "Stopping Localstack"
  $DOCKER_COMPOSE_AWS stop localstack
}

start_localstack_if_local() {
  is_local || return 0
  info "Starting Localstack"
  $DOCKER_COMPOSE_AWS up -d localstack
}

trap 'rc=$?; stop_localstack_if_local; exit $rc' INT HUP

if [ "$1" == "-h" ] || [ "$1" == "--help" ]
then
  usage
  exit 0
fi

confirm_environment_or_fail
info "Starting deployment, environment: $ENVIRONMENT"

start_localstack_if_local || exit 1
if is_local
then
  export AWS_ENDPOINT_URL="http://localstack:4566"
fi

aws_session_creds=$($DOCKER_COMPOSE_AWS \
  run --service-ports --rm obtain-aws-session-credentials) || exit 1

eval "$aws_session_creds"

if ! is_local && [ "$DEPLOY_FUNCTIONS_ONLY" == "true" ]
then
  warn "Only deploying functions, as requested."
  deploy_serverless_functions
else
  remove_secret_folder_if_present &&
    start_localstack_if_local &&
    deploy_serverless_infrastructure &&
    deploy_serverless_functions &&
    stop_localstack_if_local &&
    exit 0
fi
stop_localstack_if_local
exit 1
